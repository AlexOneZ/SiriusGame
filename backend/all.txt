1) main.py:

from fastapi import FastAPI
from contextlib import asynccontextmanager

from database import create_tables, delete_tables

from events.router import router as events_router
from teams.router import router as teams_router

@asynccontextmanager
async def lifespan(app: FastAPI):
    await delete_tables()
    print("Tables deleted")
    await create_tables()
    print("Tables created")
    yield

app = FastAPI(lifespan=lifespan)

app.include_router(teams_router)
app.include_router(events_router)

2) database.py:

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from typing import Optional

engine = create_async_engine('sqlite+aiosqlite:///database.db')

new_session = async_sessionmaker(engine, expire_on_commit=False)

class Model(DeclarativeBase):
    pass

class EventOrm(Model):
    __tablename__ = "events"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str]
    description: Mapped[Optional[str]]

class TeamOrm(Model):
    __tablename__ = "teams"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str]

async def create_tables():
    async with engine.begin() as conn:
        await conn.run_sync(Model.metadata.create_all)

async def delete_tables():
    async with engine.begin() as conn:
        await conn.run_sync(Model.metadata.drop_all)

3) teams/router.py

from fastapi import APIRouter, Depends
from typing import Annotated

from teams.repository import TeamRepository
from teams.schemas import STeam, STeamAdd, STeamId

router = APIRouter(prefix="/teams", tags=["teams"])

@router.get("")
async def get_teams() -> list[STeam]:
    events = await TeamRepository.get_all()
    return events

@router.post("")
async def enter_or_create_team(team: Annotated[STeamAdd, Depends()]) -> STeamId:
    team_id = await TeamRepository.get_id_by_name(team.name)
    if team_id is None:
        team_id = await TeamRepository.add_one(team)
    return {"ok": True, "team_id": team_id}

4) teams/schemas.py

from typing import Union
from pydantic import BaseModel

class STeamAdd(BaseModel):
    name: str

class STeam(STeamAdd):
    id: int
    
class STeamId(BaseModel):
    ok: bool = True
    team_id: int

5) teams/repository.py

from sqlalchemy import select
from typing import Optional

from database import new_session, TeamOrm
from teams.schemas import STeam, STeamAdd

class TeamRepository:
    @classmethod
    async def get_all(cls) -> list[STeam]:
        async with new_session() as session:
            query = select(TeamOrm)
            result = await session.execute(query)
            team_models = result.scalars().all()
            team_schemas = [STeam.model_validate(team_model.__dict__) for team_model in team_models]
            
            return team_schemas
    
    @classmethod
    async def get_id_by_name(cls, name: str) -> Optional[int]:
        async with new_session() as session:
            query = select(TeamOrm).where(TeamOrm.name == name)
            result = await session.execute(query)
            team_model = result.scalars().first()
            if team_model is None:
                return None
                
            team_schema = STeam.model_validate(team_model.__dict__)

            return team_schema.id

    @classmethod
    async def add_one(cls, data: STeamAdd) -> int:
        async with new_session() as session:
            new_team = TeamOrm(**data.model_dump())
            session.add(new_team)
            await session.flush()
            await session.commit()

            return new_team.id

6) events/router.py

from fastapi import APIRouter, Depends
from typing import Annotated

from events.repository import EventRepository
from events.schemas import SEventAdd, SEvent, SEventId

router = APIRouter(prefix="/events", tags=["events"])

@router.get("")
async def get_events() -> list[SEvent]:
    events = await EventRepository.get_all()
    return events
    
@router.post("")
async def add_event(event: Annotated[SEventAdd, Depends()]) -> SEventId:
    event_id = await EventRepository.add_one(event)
    return {"ok": True, "event_id": event_id}

7) events/schemas.py

from typing import Optional
from pydantic import BaseModel

class SEventAdd(BaseModel):
    name: str
    description: Optional[str] = None

class SEvent(SEventAdd):
    id: int

class SEventId(BaseModel):
    ok: bool = True
    event_id: intfrom sqlalchemy import select

8) events/repository.py

from database import new_session, EventOrm
from events.schemas import SEventAdd, SEvent

class EventRepository:
    @classmethod
    async def get_all(cls) -> list[SEvent]:
        async with new_session() as session:
            query = select(EventOrm)
            result = await session.execute(query)
            event_models = result.scalars().all()
            event_schemas = [SEvent.model_validate(event_model.__dict__) for event_model in event_models]
            
            return event_schemas

    @classmethod
    async def add_one(cls, data: SEventAdd) -> int:
        async with new_session() as session:
            event = EventOrm(**data.model_dump())
            session.add(event)
            await session.flush()
            await session.commit()

            return event.id

9) requirements.txt

fastapi
uvicorn 
sqlalchemy
aiosqlite 